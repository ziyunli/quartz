<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on</title><link>https://ziyunli.github.io/quartz/tags/Python/</link><description>Recent content in Python on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://ziyunli.github.io/quartz/tags/Python/index.xml" rel="self" type="application/rss+xml"/><item><title>__slots__ in Python</title><link>https://ziyunli.github.io/quartz/notes/slots_in_python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ziyunli.github.io/quartz/notes/slots_in_python/</guid><description>&lt;p>今天在公司内部交流会上聊到了我们Python后端代码中的一个小问题：在一小段代码中，我们遍历了所有的&amp;quot;item&amp;quot;，然后选了一个ID，把每个&amp;quot;item&amp;quot;都塞进了一个dict里面。
先不论这段代码的具体功能，光从实现来说当初的设计咋一看没有太大的问题，但是现在，我们客户数据库里面动不动就能翻出上千个&amp;quot;item&amp;quot;时，这段代码带来了不小的内存开销，而我们能怎么改善这个情况呢？&lt;/p></description></item><item><title>Data Classes in Python</title><link>https://ziyunli.github.io/quartz/notes/data_classes_in_python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ziyunli.github.io/quartz/notes/data_classes_in_python/</guid><description>dataclass decorator is introduced since Python 3.7.
A decorated class behaves like a regular Python class, but it automatically generates several dunder methods: __init__, __eq__, and __repr__.</description></item></channel></rss>