<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on</title><link>https://ziyunli.github.io/quartz/tags/Python/</link><description>Recent content in Python on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://ziyunli.github.io/quartz/tags/Python/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://ziyunli.github.io/quartz/notes/__slots__-in-Python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ziyunli.github.io/quartz/notes/__slots__-in-Python/</guid><description>今天在公司内部交流会上聊到了我们Python后端代码中的一个小问题：在一小段代码中，我们遍历了所有的&amp;quot;item&amp;quot;，然后选了一个ID，把每个&amp;quot;item&amp;quot;都塞进了一个dict里面。 先不论这段代码的具体功能，光从实现来说当初的设计咋一看没有太大的问题，但是现在，我们客户数据库里面动不动就能翻出上千个&amp;quot;item&amp;quot;时，这段代码带来了不小的内存开销，而我们能怎么改善这个情况呢？
首先，class是解决不了问题的：默认下，每个class都有一个内建的dict，把attribute names对应到具体的数值，再加上一些别的metadata，class占用的内存会比dict更加多。
1 2 3 4 5 6 7 8 9 class Rectangle: def __init__(self, top, bottom, left, right): self.</description></item><item><title/><link>https://ziyunli.github.io/quartz/notes/Data-Classes-in-Python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ziyunli.github.io/quartz/notes/Data-Classes-in-Python/</guid><description>dataclass decorator is introduced since Python 3.7.
A decorated class behaves like a regular Python class, but it automatically generates several dunder methods: __init__, __eq__, and __repr__.</description></item></channel></rss>